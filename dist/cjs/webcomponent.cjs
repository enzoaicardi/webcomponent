"use strict";class t extends Error{constructor(t){super(t)}}class e extends t{constructor(t,e){super(`Missing property ${t} on ${e.name}`),this.name="PropertyRequiredError"}}const s="undefined"==typeof document,r=!s,i=s?class{}:HTMLElement,n=s?null:document.createElement("template"),c=new Set,o=t=>{if(r&&t)throw t.tagName&&(c.has(t)||(c.add(t),customElements.define(t.tagName,t))),new e("static tagName",t)},h=(t,e)=>`<${e}>${t}</${e}>`;class a{static t=Symbol();static i=Symbol()}class u extends i{static tagName;static define=o;static createElement(...t){return o(this),new this(...t)}static createRaw(...t){return o(this),new this(...t).toString()}[a.i]=Object.getPrototypeOf(this).constructor;[a.t](t){const e=(t=>n?(n.innerHTML=t,n.content):null)(t);e&&this.appendChild(e)}constructor(){super()}connectedCallback(){const t=this;if(!t.childNodes.length)if(this.render)this[a.t](this.render());else if(this.renderAsync)return this.renderAsync().then((e=>(this[a.t](e),t)));return Promise.resolve(t)}toString(){const t=this[a.i],s=t.tagName;if(!s)throw new e("static tagName",t);if(this.render)return h(this.render(),s);if(this.renderAsync)return this.renderAsync().then((t=>h(t,s)));throw new e("render | renderAsync",t)}[Symbol.toPrimitive](){if(this.render)return h(this.render(),this[a.i].tagName);throw new e("render",this[a.i])}}exports.WebComponent=u,exports.isClient=r,exports.isServer=s;
