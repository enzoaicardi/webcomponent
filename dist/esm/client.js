class t extends Error{constructor(t){super(`[${t.name}] Missing static property tagName.`),this.name="MissingTagName"}}class e extends Error{constructor(t){super(`[${t.name} ${t.tagName}] Cannot render component without rendering method (render | renderAsync).`),this.name="MissingRenderingMethod"}}class n extends Error{constructor(t){super(`[${t.name} ${t.tagName}] Unauthorized implicit coercion without synchronous rendering. Use toString instead.`),this.name="UnauthorizedCoercion"}}const s=function(){const e=Object.getPrototypeOf(this).constructor;if(!e.tagName)throw new t(e);return customElements.get(e.tagName)||customElements.define(e.tagName,e),Reflect.construct(HTMLElement,[],new.target)};function i(e,n){const s=e.definition.tagName;if(s){let t="";for(const{name:n,value:s}of e.attributes)s+""!=""&&(t+=/[^:.\w_-]/.test(n)?"":` ${n}="${s}"`);return`<${s}${t}>${n}</${s}>`}throw new t(e.definition)}(s.prototype=HTMLElement.prototype).constructor=s;const r=document.createElement("template");class o extends(function(t=class{}){return class extends t{static tagName;definition=Object.getPrototypeOf(this).constructor;toString(){if(this.render)return i(this,this.render());if(this.renderAsync)return this.renderAsync().then((t=>i(this,t)));throw new e(this.definition)}[Symbol.toPrimitive](){if(this.render)return i(this,this.render());throw new n(this.definition)}}}(s)){static tagName;connectedCallback(){if(!this.childNodes.length)if(this.render)c(this,this.render());else if(this.renderAsync)return this.renderAsync().then((t=>c(this,t)))}}function c(t,e){r.innerHTML=e;const n=r.content;t.appendChild(n)}export{o as WebComponent};
